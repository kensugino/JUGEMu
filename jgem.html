<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Supplemental Material: jGEM document &mdash; jGEM 0.9.0 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.3.4/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.3.4/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="jGEM 0.9.0 documentation" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          jGEM</a>
        <span class="navbar-text navbar-version pull-left"><b>0.9.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">jGEM packages</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Supplemental Material: jGEM document</a><ul>
<li><a class="reference internal" href="#finding-exon-candidates-from-junctions">Finding exon candidates from junctions</a></li>
<li><a class="reference internal" href="#finding-internal-edge-exons">Finding internal, edge exons</a></li>
<li><a class="reference internal" href="#assigning-strandedness">Assigning strandedness</a></li>
<li><a class="reference internal" href="#refining-edge-exons">Refining edge exons</a></li>
<li><a class="reference internal" href="#finding-intron-retensions">Finding intron retensions</a></li>
<li><a class="reference internal" href="#finding-threshold-for-single-exon-coverage">Finding threshold for single exon coverage</a></li>
<li><a class="reference internal" href="#finding-single-exons">Finding single exons</a></li>
<li><a class="reference internal" href="#calculating-exon-coverages">Calculating exon coverages</a></li>
<li><a class="reference internal" href="#finding-genes">Finding genes</a></li>
<li><a class="reference internal" href="#calculating-gene-coverages">Calculating gene coverages</a></li>
<li><a class="reference internal" href="#evaluation-of-assemblies-at-individual-sample-level">Evaluation of assemblies at individual sample level</a></li>
<li><a class="reference internal" href="#merging">Merging</a></li>
<li><a class="reference internal" href="#evalulation-of-merged-assembly">Evalulation of merged assembly</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="_sources/jgem.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput,
div.nbinput > div,
div.nbinput div[class^=highlight],
div.nbinput div[class^=highlight] pre,
div.nboutput,
div.nboutput > div,
div.nboutput div[class^=highlight],
div.nboutput div[class^=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput div[class^=highlight] pre {
    line-height: unset;
}

/* input/output containers */
div.nbinput,
div.nboutput {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
}

/* input container */
div.nbinput {
    padding-top: 5px;
}

/* last container */
div.nblast {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput > :first-child pre {
    color: #303F9F;
}

/* output prompt */
div.nboutput > :first-child pre {
    color: #D84315;
}

/* all prompts */
div.nbinput > :first-child[class^=highlight],
div.nboutput > :first-child[class^=highlight],
div.nboutput > :first-child {
    min-width: 11ex;
    padding-top: 0.4em;
    padding-right: 0.4em;
    text-align: right;
    flex: 0;
}

/* input/output area */
div.nbinput > :nth-child(2)[class^=highlight],
div.nboutput > :nth-child(2),
div.nboutput > :nth-child(2)[class^=highlight] {
    padding: 0.4em;
    -webkit-flex: 1;
    flex: 1;
}

/* input area */
div.nbinput > :nth-child(2)[class^=highlight] {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    background: #f7f7f7;
}

/* override MathJax center alignment in output cells */
div.nboutput div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.pngmath center alignment in output cells */
div.nboutput div.math p {
    text-align: left;
}

/* standard error */
div.nboutput  > :nth-child(2).stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-bold { font-weight: bold; }
</style>
<div class="section" id="supplemental-material-jgem-document">
<span id="supplemental-material-jgem-document"></span><h1>Supplemental Material: jGEM document<a class="headerlink" href="#supplemental-material-jgem-document" title="Permalink to this headline">Â¶</a></h1>
<p>The basic idea of the assembler is very simple. It uses splice junctions and read coverage to find exon boundaries. Candidate exons whose boundaries are spliced can be easily constructed from junctions. Using read coverage, these candidate exons are further refined into internal exons and edge exons (5&#8217; or 3&#8217; exons). Then, intron retensions and single exons are added with the aid of read coverage. A gene (locus) is defined as a connected component of extracted exons, where junctions and overlaps are connections (Supplemental Figure 7A, B). This assembler does not attempt to estimate isoform abundance. Instead it aims to obtain complete collections of exons and junctions. In the followings, more details of the each step will be described.</p>
<div class="section" id="finding-exon-candidates-from-junctions">
<span id="finding-exon-candidates-from-junctions"></span><h2>Finding exon candidates from junctions<a class="headerlink" href="#finding-exon-candidates-from-junctions" title="Permalink to this headline">Â¶</a></h2>
<p>Because of the strandedness of the canonical splice junctions, most of the junction reads can be assigned with strandedness even for unstranded RANSeq experiments. All of the following steps are separately performed for each strand. Junctions with unknown strand are used in both cases to construct initial exon candidates but afterwards strandedness is assigned to these unstranded junctions or exons through strandedness of the connected components defined by the majority.</p>
<p>Junctions with the same strandedness define collections of start positions and end positions of candidate exons. A candidate exon is defined as a pair of nearest start and end (Supplemental Figure 7A). However, when the size of candidate exon is larger than a set size (currently 35kbp), then it is broken into two edge exons with temporary size (100bp). ( In the GencodeVM4, average exon size is 350bp. Well known big gene Titin (Ttn) has a 17kbp exon. There are four exons larger than 35kbp, largest being 84kbp exon in Kcnq1ot1. )</p>
</div>
<div class="section" id="finding-internal-edge-exons">
<span id="finding-internal-edge-exons"></span><h2>Finding internal, edge exons<a class="headerlink" href="#finding-internal-edge-exons" title="Permalink to this headline">Â¶</a></h2>
<p>These candidate exons found in the previous step are further refined into internal exons and edge exons using read coverage information. We define &#8220;mapped portion&#8221; as the portion of the interval covered by mapped reads. This quantity is also called &#8220;coverage&#8221; but we will call it &#8220;mapped portion&#8221; here to distinguish with the other &#8220;coverage&#8221; which is the sum of all the base pairs of the mapped reads on the interval divided by the length of the interval. The candidate exons with mapped portion greater than a set value (here 0.95) are categorized as internal exons and the rest are broken into edge exons.</p>
</div>
<div class="section" id="assigning-strandedness">
<span id="assigning-strandedness"></span><h2>Assigning strandedness<a class="headerlink" href="#assigning-strandedness" title="Permalink to this headline">Â¶</a></h2>
<p>After previous step of breaking possible connections between genes, connected components are used to assign strands to unstranded elements. Junctions are used as connections and the most abundant strand of the elements of a connected component is used as the strand of the connected compnent.</p>
</div>
<div class="section" id="refining-edge-exons">
<span id="refining-edge-exons"></span><h2>Refining edge exons<a class="headerlink" href="#refining-edge-exons" title="Permalink to this headline">Â¶</a></h2>
<p>So far, edge exons are assigned with arbitrary temporary size. In this step, using read coverage, the other boundaries of the edge exons are searched. From one end (spliced end), the interval is extended while the interval is covered by reads ignoring gaps smaller than a set value (currently 50bp for both 5&#8217; and 3&#8217; exons). However, when a donor (for 3&#8217; exon) or an acceptor (for 5&#8217; exon) site is encountered, then extension is terminated at that position. To avoid inclusion of noise, when there is a sudden decrease of coverage (&lt;x0.1) after a gap, then extension is also terminated before the gap.</p>
</div>
<div class="section" id="finding-intron-retensions">
<span id="finding-intron-retensions"></span><h2>Finding intron retensions<a class="headerlink" href="#finding-intron-retensions" title="Permalink to this headline">Â¶</a></h2>
<p>In the first step, candidate internal exons are defined by &#8220;nearest&#8221; start and end positions. Other possible combinations of start and end positions occur when there are intron retentions. Intron retentions are detected as the junctions with mapped portion larger than a set value (0.98).</p>
</div>
<div class="section" id="finding-threshold-for-single-exon-coverage">
<span id="finding-threshold-for-single-exon-coverage"></span><h2>Finding threshold for single exon coverage<a class="headerlink" href="#finding-threshold-for-single-exon-coverage" title="Permalink to this headline">Â¶</a></h2>
<p>We can find candidates of single exons as read mapped intervals outside of already extracted multi-exon models. However, since single exon genes do not have well defined spliced boundaries, it is very difficult to distinguish them from noise. Often used property to limit noise is the coverage, but how to find appropriate threshold value has not been explored and rather arbitrary values have been used in other programs.</p>
<p>We found that read coverage of exons with some number (gamma) added follows power law distribution (Supplemental Figure 7C,D). For each sample, using GencodeVM4 annotation (or using multi-exon models extracted up to the previous step), we find optimum gamma by fitting log-log histogram by a line (Supplemental Figure 7D top). Optimum gammas are usually in the range of 0.5 to 1. Interestingly gamma found using all exons including single exons in GencodeVM4 usually fit well for extracted multi-exon models, indicating that extracted single exons also should follow this power law. Using this, we can find a threshold coverage for 1% false positive rate for single exons (Supplemental Figure 7D bottom).</p>
</div>
<div class="section" id="finding-single-exons">
<span id="finding-single-exons"></span><h2>Finding single exons<a class="headerlink" href="#finding-single-exons" title="Permalink to this headline">Â¶</a></h2>
<p>Using the coverage threshold found in the previous step and length threshold (&gt;200bp), single exon candidates are extracted. Some of these candidates are next to already extracted (spliced) exons and these were joined and made into 5&#8217; or 3&#8217; exons.</p>
</div>
<div class="section" id="calculating-exon-coverages">
<span id="calculating-exon-coverages"></span><h2>Calculating exon coverages<a class="headerlink" href="#calculating-exon-coverages" title="Permalink to this headline">Â¶</a></h2>
<p>To calculate coverages of exons which may have overlaps, we first divide exon intervals into intervals with constant set of overlaps, which we call &#8220;chopped interval&#8221;. Over one of these intervals, the set of exons overlapping are not changing. First, for each of these chopped interval read coverage are calculated. Then, to estimate exon coverages, linear equations defined by the relationships between exon intervals and chopped intervals (assuming constancy of coverage over each interval) are solved with non-negativity constraint.</p>
</div>
<div class="section" id="finding-genes">
<span id="finding-genes"></span><h2>Finding genes<a class="headerlink" href="#finding-genes" title="Permalink to this headline">Â¶</a></h2>
<p>After finding spliced exons and single exons, genes (loci) are found as connected components where connections are junctions and exon overlaps.</p>
</div>
<div class="section" id="calculating-gene-coverages">
<span id="calculating-gene-coverages"></span><h2>Calculating gene coverages<a class="headerlink" href="#calculating-gene-coverages" title="Permalink to this headline">Â¶</a></h2>
<p>A coverage for a gene is calculated using the union of the intervals of the exons belonging to the gene. To account for the overlaps between exons, chopped interval method described above was used but instead of solving linear equations, coverage calculated from the lengths and the coverages of unique chopped intervals belonging to the gene is used.</p>
</div>
<div class="section" id="evaluation-of-assemblies-at-individual-sample-level">
<span id="evaluation-of-assemblies-at-individual-sample-level"></span><h2>Evaluation of assemblies at individual sample level<a class="headerlink" href="#evaluation-of-assemblies-at-individual-sample-level" title="Permalink to this headline">Â¶</a></h2>
<p>Sensitivity of the assemblers were evaluated against GencodeVM4 annotation. For each GencodeVM4 exon with positive coverage, whether that exon is detected or not is scored. GencodeVM4 exons are sorted by their coverage values and for each bin of 1000 exons average detection rate is calculated and plotted against average coverage within the bin (Supplemental Figure 7E). Normalized area under the curves (AUCs) for all the samples are plotted in Supplemental Figure 7F. jGEM consistently performed better than Cufflinks and StringTie.</p>
<p>Number of detected genes are plotted in Supplemental Figure 7G (1st and 2nd rows). Number of GencodeVM4 genes with coverage &gt;0 and jGEM gene numbers are very close and they both increase in tissue samples (toward the right end) compared to cell type-specific samples, which is consistent with the complexity of the tissue samples.</p>
<p>The number of jGEM single exon genes were slightly lower than that of GencodeVM4 single exon genes with coverage &gt; 0 (2nd row) due to stringent thresholding, however, other assemblers had an order of magnitude larger number of single exon genes (note that y-axis is in log scale).</p>
</div>
<div class="section" id="merging">
<span id="merging"></span><h2>Merging<a class="headerlink" href="#merging" title="Permalink to this headline">Â¶</a></h2>
<p>Upon examining extracted gene/exon models from all the samples, it turned out that a lot of 5&#8217;,3&#8217;-exons were actually incomplete internal exons. Therefore, to obtain more complete models, an assembly process is repeated using extracted exons from all the samples as pseudo reads.</p>
<p>An exon from a sample is treated as reads which span the same interval as the exon and the read number proportional to the coverage of the exon. However, we only used exons with coverage &gt; 0.2    5. From the collection of these pseudo reads, coverage (bigwig) is calculated and used as the input to the assembler. For junctions, all the junctions from all the samples were aggregated and then junctions with aggregated unique reads &gt; 50 or non-unique reads &gt; 200 were used as the input to the assembler. The junction counts were normalized to library sizes before aggregation. Positive strand and negative strand were treated separately. Unstranded elements, especially single exons, were added to both strands.</p>
<p>Slightly different parameters were used for assembly for merging (e.g. threshold mapped portion for defining internal exons is 0.999 instead of 0.95, gap for extending edge exons is 1bp instead of 50bp).  Since the extracted models were used to construct the genome coverage, the &#8220;shape&#8221; of the coverage contained information on different ends of 5&#8217; or 3&#8217; exons or on intron retension, therefore, an algorithm analyzing coverage &#8220;shape&#8221; is used for extending edge exons and finding intron retentions.</p>
<p>The separately merged models from positive strand and negative strand are combined but single exons overlapping to the opposite strand are removed as artefacts. Models with extremely low transcript length to gene length ratio (Supplemental Figure 7H red dashed region) are removed.  These models mostly consisted with two exon models with extremely low exon lengths or incomplete models (usually 5&#8217; portion of a long gene).</p>
</div>
<div class="section" id="evalulation-of-merged-assembly">
<span id="evalulation-of-merged-assembly"></span><h2>Evalulation of merged assembly<a class="headerlink" href="#evalulation-of-merged-assembly" title="Permalink to this headline">Â¶</a></h2>
<p>Evaluation of merged models are shown in Figure 2C, D. In general merged models have much better sensitivity than that of individual samples.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2016, Ken Sugino.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>